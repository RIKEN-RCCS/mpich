--- src/mpid/ch4/netmod/ofi/ofi_events.c
+++ src/mpid/ch4/netmod/ofi/ofi_events.c
@@ -83,7 +83,15 @@ static int peek_event(struct fi_cq_tagged_entry *wc, MPIR_Request * rreq)
             recv_elem->event_id = MPIDI_OFI_EVENT_GET_HUGE;
             recv_elem->done_fn = recv_event;
             recv_elem->wc = *wc;
+// YI
+#define TOFU
+#ifdef TOFU /* YI 20201213 */
+            recv_elem->cur_offset = MPIDI_OFI_global.max_short_send;
+	    //printf("%s: YI!!! cur_offset = 0x%lx\n", __func__, recv_elem->cur_offset); fflush(stdout);
+	    //fprintf(stderr, "%s: YI!!! cur_offset = 0x%lx\n", __func__, recv_elem->cur_offset); fflush(stderr);
+#else
             recv_elem->cur_offset = MPIDI_OFI_global.max_msg_size;
+#endif
 
             LL_APPEND(MPIDI_posted_huge_recv_head, MPIDI_posted_huge_recv_tail, huge_list_ptr);
             goto fn_exit;
@@ -137,6 +145,7 @@ static int recv_event(struct fi_cq_tagged_entry *wc, MPIR_Request * rreq, int ev
     MPIR_FUNC_VERBOSE_STATE_DECL(MPID_STATE_RECV_EVENT);
     MPIR_FUNC_VERBOSE_ENTER(MPID_STATE_RECV_EVENT);
 
+    // printf("%s: event_id = %d\n", __func__); fflush(stdout); fprintf(stderr, "%s: event_id = %d\n", __func__); fflush(stderr);
     rreq->status.MPI_SOURCE = cqe_get_source(wc, true);
     rreq->status.MPI_ERROR = MPIDI_OFI_idata_get_error_bits(wc->data);
     rreq->status.MPI_TAG = MPIDI_OFI_init_get_tag(wc->tag);
@@ -222,12 +231,24 @@ static int recv_huge_event(struct fi_cq_tagged_entry *wc, MPIR_Request * rreq)
 
     /* Check that the sender didn't underflow the message by sending less than
      * the huge message threshold. */
+
+#define TOFU
+#ifdef TOFU
+    // printf("%s: YIYI wc->len(%d), short_send(%d) in %s\n", __func__, wc->len, MPIDI_OFI_global.max_short_send, __FILE__); fflush(stdout);
+    // fprintf(stderr, "%s: YIYI wc->len(%d), short_send(%d) in %s\n", __func__, wc->len, MPIDI_OFI_global.max_short_send, __FILE__); fflush(stderr);
+    if (wc->len < MPIDI_OFI_global.max_short_send) {
+        return recv_event(wc, rreq, MPIDI_OFI_REQUEST(rreq, event_id));
+    }
+#else
     if (wc->len < MPIDI_OFI_global.max_msg_size) {
         return recv_event(wc, rreq, MPIDI_OFI_REQUEST(rreq, event_id));
     }
+#endif
 
     comm_ptr = rreq->comm;
 
+    // printf("%s:\t YIYI comm_ptr(%p)\n", __func__, comm_ptr); fflush(stdout);
+    // fprintf(stderr, "%s:\t YIYI comm_ptr(%p)\n", __func__, comm_ptr); fflush(stderr);
     /* Check to see if the tracker is already in the unexpected list.
      * Otherwise, allocate one. */
     {
@@ -257,6 +278,9 @@ static int recv_huge_event(struct fi_cq_tagged_entry *wc, MPIR_Request * rreq)
         }
     }
 
+    // printf("%s:\t YIYI recv_elem(%p)\n", __func__, recv_elem); fflush(stdout);
+    // fprintf(stderr, "%s:\t YIYI recv_elem(%p)\n", __func__, recv_elem); fflush(stderr);
+
     if (recv_elem == NULL) {
         MPIDI_OFI_huge_recv_list_t *list_ptr;
 
@@ -279,7 +303,12 @@ static int recv_huge_event(struct fi_cq_tagged_entry *wc, MPIR_Request * rreq)
         list_ptr->tag = (MPIDI_OFI_TAG_MASK & wc->tag);
         list_ptr->rreq = rreq;
 
+	//printf("%s: YI--- ptr->comm_id(%d), rank(%d), tag(%lx)\n",
+	// __func__, list_ptr->comm_id, list_ptr->rank, list_ptr->tag); fflush(stdout);
+
         LL_APPEND(MPIDI_posted_huge_recv_head, MPIDI_posted_huge_recv_tail, list_ptr);
+
+	//printf("%s: \t MPIDI_posted_huge_recv_head = %p\n", __func__, MPIDI_posted_huge_recv_head); fflush(stdout);
     }
 
     /* Plug the information for the huge event into the receive request and go
@@ -290,6 +319,7 @@ static int recv_huge_event(struct fi_cq_tagged_entry *wc, MPIR_Request * rreq)
     recv_elem->localreq = rreq;
     recv_elem->done_fn = recv_event;
     recv_elem->wc = *wc;
+
     MPIDI_OFI_get_huge_event(NULL, (MPIR_Request *) recv_elem);
 
   fn_exit:
@@ -403,6 +433,7 @@ int MPIDI_OFI_get_huge_event(struct fi_cq_tagged_entry *wc, MPIR_Request * req)
     MPIR_FUNC_VERBOSE_STATE_DECL(MPID_STATE_MPIDI_OFI_GET_HUGE_EVENT);
     MPIR_FUNC_VERBOSE_ENTER(MPID_STATE_MPIDI_OFI_GET_HUGE_EVENT);
 
+//    fprintf(stderr, "YIYI %s: localreq(%p) cur_offset(0x%lx) in %s\n", __func__, recv_elem->localreq, recv_elem->cur_offset, __FILE__); fflush(stderr); fprintf(stdout, "YIYI %s: localreq(%p) cur_offset(0x%lx) in %s\n", __func__, recv_elem->localreq, recv_elem->cur_offset, __FILE__); fflush(stdout);
     if (recv_elem->localreq && recv_elem->cur_offset != 0) {    /* If this is true, then the message has a posted
                                                                  * receive already and we'll be able to find the
                                                                  * struct describing the transfer. */
@@ -414,6 +445,9 @@ int MPIDI_OFI_get_huge_event(struct fi_cq_tagged_entry *wc, MPIR_Request * req)
             (bytesLeft <=
              MPIDI_OFI_global.max_msg_size) ? bytesLeft : MPIDI_OFI_global.max_msg_size;
 
+	//fprintf(stderr, "YIYI %s: remote_info.msgsize(%ld), buytesSent(%ld) bytesToGet(%ld)\n", __func__, recv_elem->remote_info.msgsize, bytesSent, bytesToGet); fflush(stderr);
+	//fprintf(stdout, "YIYI %s: remote_info.msgsize(%ld), buytesSent(%ld) bytesToGet(%ld)\n", __func__, recv_elem->remote_info.msgsize, bytesSent, bytesToGet); fflush(stdout);
+
         if (bytesToGet == 0ULL) {
             MPIDI_OFI_send_control_t ctrl;
             /* recv_elem->localreq may be freed during done_fn.
@@ -599,6 +633,8 @@ static int am_recv_event(struct fi_cq_tagged_entry *wc, MPIR_Request * rreq)
     void *orig_buf = wc->buf;   /* needed in case we will copy the header for alignment fix */
     am_hdr = (MPIDI_OFI_am_header_t *) wc->buf;
 
+    //printf("%s: YIYI enter am_hdr->am_type(%d)\n", __func__, am_hdr->am_type); fflush(stdout);
+    //fprintf(stderr, "%s: YIYI enter am_hdr->am_type(%d)\n", __func__, am_hdr->am_type); fflush(stderr);
 #if NEEDS_STRICT_ALIGNMENT
     /* FI_MULTI_RECV may pack the message at lesser alignment, copy the header
      * when that's the case */
@@ -761,6 +801,7 @@ int MPIDI_OFI_dispatch_function(struct fi_cq_tagged_entry *wc, MPIR_Request * re
 {
     int mpi_errno = MPI_SUCCESS;
 
+    //printf("%s: YIYI MPIDI_OFI_REQUEST = %d MPIDI_OFI_EVENT_SEND_HUGE(%d) MPIDI_OFI_global.max_short_send(%d) in %s\n", __func__, MPIDI_OFI_REQUEST(req, event_id),MPIDI_OFI_EVENT_SEND_HUGE,  MPIDI_OFI_global.max_short_send, __FILE__); fflush(stdout);    fprintf(stderr, "%s: YIYI MPIDI_OFI_REQUEST = %d MPIDI_OFI_EVENT_SEND_HUGE(%d) in %s\n", __func__, MPIDI_OFI_REQUEST(req, event_id),MPIDI_OFI_EVENT_SEND_HUGE,  __FILE__); fflush(stderr);
     if (likely(MPIDI_OFI_REQUEST(req, event_id) == MPIDI_OFI_EVENT_SEND)) {
         /* Passing the event_id as a parameter; do not need to load it from the
          * request object each time the send_event handler is invoked */
